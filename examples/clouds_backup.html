<!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.181.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.181.0/examples/jsm/",
          "postprocessing": "https://unpkg.com/postprocessing@6.37.3/build/index.js",
          "@takram/three-geospatial": "https://unpkg.com/@takram/three-geospatial@0.5.1/build/index.js",
          "@takram/three-geospatial/shaders": "https://unpkg.com/@takram/three-geospatial@0.5.1/build/shaders.js",
          "@takram/three-geospatial-effects": "https://unpkg.com/@takram/three-geospatial-effects@0.4.3/build/index.js",
          "@takram/three-atmosphere": "https://unpkg.com/@takram/three-atmosphere@0.15.1/build/index.js",
          "@takram/three-clouds": "https://cdn.jsdelivr.net/npm/@takram/three-clouds@0.6.0/+esm"
        }
      }
    </script>
    <script type="module">
      import {
        EffectComposer,
        EffectPass,
        RenderPass,
        ToneMappingEffect,
        ToneMappingMode
      } from 'postprocessing'
      import {
        Clock,
        Group,
        HalfFloatType,
        Mesh,
        MeshPhysicalMaterial,
        NoToneMapping,
        PCFSoftShadowMap,
        PerspectiveCamera,
        PlaneGeometry,
        Scene,
        TorusKnotGeometry,
        Vector3,
        WebGLRenderer
      } from 'three'
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

      import {
        AerialPerspectiveEffect,
        getMoonDirectionECEF,
        getSunDirectionECEF,
        PrecomputedTexturesGenerator,
        SkyLightProbe,
        SkyMaterial,
        SunDirectionalLight
      } from '@takram/three-atmosphere'
      import { CloudsEffect } from '@takram/three-clouds'
      import { Ellipsoid, Geodetic, radians } from '@takram/three-geospatial'
      import {
        DitheringEffect,
        LensFlareEffect
      } from '@takram/three-geospatial-effects'

      let renderer
      let camera
      let controls
      let clock
      let scene
      let skyMaterial
      let skyLight
      let sunLight
      let aerialPerspective
      let cloudsEffect
      let composer

      const sunDirection = new Vector3()
      const moonDirection = new Vector3()

      // A midnight sun in summer.
      const referenceDate = new Date('2000-06-01T18:00:00Z')
      const geodetic = new Geodetic(0, radians(67), 1000)
      const position = geodetic.toECEF()
      const up = Ellipsoid.WGS84.getSurfaceNormal(position)

      function init() {
        const container = document.getElementById('container')

        {
          const aspect = window.innerWidth / window.innerHeight
          camera = new PerspectiveCamera(75, aspect, 10, 1e6)
          camera.position.copy(position)
          camera.up.copy(up)

          controls = new OrbitControls(camera, container)
          controls.enableDamping = true
          controls.minDistance = 1e3
          controls.target.copy(position)

          clock = new Clock()
          scene = new Scene()
        }

        {
          skyMaterial = new SkyMaterial()
          const sky = new Mesh(new PlaneGeometry(2, 2), skyMaterial)
          sky.frustumCulled = false
          scene.add(sky)

          skyLight = new SkyLightProbe()
          skyLight.position.copy(position)
          scene.add(skyLight)

          sunLight = new SunDirectionalLight({ distance: 300 })
          sunLight.target.position.copy(position)
          sunLight.castShadow = true
          sunLight.shadow.camera.top = 300
          sunLight.shadow.camera.bottom = -300
          sunLight.shadow.camera.left = -300
          sunLight.shadow.camera.right = 300
          sunLight.shadow.camera.near = 0
          sunLight.shadow.camera.far = 600
          sunLight.shadow.mapSize.width = 2048
          sunLight.shadow.mapSize.height = 2048
          sunLight.shadow.normalBias = 1
          scene.add(sunLight)
          scene.add(sunLight.target)
        }

        {
          const group = new Group()
          Ellipsoid.WGS84.getEastNorthUpFrame(position).decompose(
            group.position,
            group.quaternion,
            group.scale
          )
          scene.add(group)

          const torusKnot = new Mesh(
            new TorusKnotGeometry(200, 60, 256, 64),
            new MeshPhysicalMaterial({
              color: 'white',
              roughness: 0.5,
              ior: 1.45,
              clearcoat: 1,
              clearcoatRoughness: 0.1
            })
          )
          torusKnot.castShadow = true
          torusKnot.receiveShadow = true
          group.add(torusKnot)
        }

        aerialPerspective = new AerialPerspectiveEffect(camera)

        // cloudsEffect = new CloudsEffect()
        cloudsEffect = new CloudsEffect(camera, {
          resolutionScale: 0.5,
          width: window.innerWidth,
          height: window.innerHeight
        })
        console.log(cloudsEffect)

        renderer = new WebGLRenderer({
          depth: false,
          logarithmicDepthBuffer: true
        })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.toneMapping = NoToneMapping
        renderer.toneMappingExposure = 10
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = PCFSoftShadowMap

        composer = new EffectComposer(renderer, {
          frameBufferType: HalfFloatType,
          multisampling: 8
        })
        composer.addPass(new RenderPass(scene, camera))
        composer.addPass(
          new EffectPass(
            camera,
            aerialPerspective,
            cloudsEffect,
            new LensFlareEffect(),
            new ToneMappingEffect({ mode: ToneMappingMode.AGX }),
            new DitheringEffect()
          )
        )

        const generator = new PrecomputedTexturesGenerator(renderer)
        generator.update().catch(error => {
          console.error(error)
        })

        const textures = generator.textures
        Object.assign(skyMaterial, textures)
        Object.assign(aerialPerspective, textures)
        cloudsEffect.sunDirection.copy(sunDirection)

        container.appendChild(renderer.domElement)
        window.addEventListener('resize', onWindowResize)
        renderer.setAnimationLoop(render)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
        cloudsEffect.setSize(window.innerWidth, window.innerHeight)
      }

      function render() {
        const date = +referenceDate + ((clock.getElapsedTime() * 5e6) % 864e5)
        getSunDirectionECEF(date, sunDirection)
        getMoonDirectionECEF(date, moonDirection)

        skyMaterial.sunDirection.copy(sunDirection)
        skyMaterial.moonDirection.copy(moonDirection)

        sunLight.sunDirection.copy(sunDirection)
        skyLight.sunDirection.copy(sunDirection)
        aerialPerspective.sunDirection.copy(sunDirection)
        cloudsEffect.sunDirection.copy(sunDirection)

        if (cloudsEffect && typeof cloudsEffect.update === 'function') {
          // 方案1：如果 update 方法需要输入缓冲区，尝试传递 readBuffer
          cloudsEffect.update(renderer, composer.readBuffer, clock.getDelta());

          // 方案2（更常见）：如果效果已加入 composer 的渲染管线，可能只需更新其uniforms或状态
          // 具体调用方式需参考 three-clouds 库的文档或示例
          // cloudsEffect.update(renderer, clock.getDelta()) // 假设不需要显式传递 renderTarget
        }

        sunLight.update()
        skyLight.update()

        composer.render()
        controls.update()
      }

      init()
    </script>
  </body>
</html>

<!-- <!doctype html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.181.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.181.0/examples/jsm/",
          "postprocessing": "https://unpkg.com/postprocessing@6.37.3/build/index.js",
          "@takram/three-geospatial": "https://unpkg.com/@takram/three-geospatial@0.5.1/build/index.js",
          "@takram/three-geospatial/shaders": "https://unpkg.com/@takram/three-geospatial@0.5.1/build/shaders.js",
          "@takram/three-geospatial-effects": "https://unpkg.com/@takram/three-geospatial-effects@0.4.3/build/index.js",
          "@takram/three-atmosphere": "https://unpkg.com/@takram/three-atmosphere@0.15.1/build/index.js",
          "@takram/three-clouds": "https://cdn.jsdelivr.net/npm/@takram/three-clouds@0.6.0/+esm"
        }
      }
    </script>
    <script type="module">
      import {
        EffectComposer,
        EffectPass,
        RenderPass,
        ToneMappingEffect,
        ToneMappingMode
      } from 'postprocessing'
      import {
        Clock,
        Group,
        HalfFloatType,
        Mesh,
        MeshPhysicalMaterial,
        NoToneMapping,
        PCFSoftShadowMap,
        PerspectiveCamera,
        PlaneGeometry,
        Scene,
        TorusKnotGeometry,
        Vector3,
        WebGLRenderer
      } from 'three'
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

      import {
        AerialPerspectiveEffect,
        getMoonDirectionECEF,
        getSunDirectionECEF,
        PrecomputedTexturesGenerator,
        SkyLightProbe,
        SkyMaterial,
        SunDirectionalLight
      } from '@takram/three-atmosphere'
      import { CloudsEffect } from '@takram/three-clouds'
      import { Ellipsoid, Geodetic, radians } from '@takram/three-geospatial'
      import {
        DitheringEffect,
        LensFlareEffect
      } from '@takram/three-geospatial-effects'

      let renderer
      let camera
      let controls
      let clock
      let scene
      let skyMaterial
      let skyLight
      let sunLight
      let aerialPerspective
      let composer

      const sunDirection = new Vector3()
      const moonDirection = new Vector3()

      // A midnight sun in summer.
      // const referenceDate = new Date('2000-06-01T18:00:00Z')
      const geodetic = new Geodetic(0, radians(67), 1000)
      const position = geodetic.toECEF()
      const up = Ellipsoid.WGS84.getSurfaceNormal(position)

      function init() {
        const container = document.getElementById('container')

        {
          const aspect = window.innerWidth / window.innerHeight
          camera = new PerspectiveCamera(75, aspect, 10, 1e6)
          camera.position.copy(position)
          camera.up.copy(up)

          controls = new OrbitControls(camera, container)
          controls.enableDamping = true
          controls.minDistance = 1e3
          controls.target.copy(position)

          clock = new Clock()
          scene = new Scene()
        }

        {
          // SkyMaterial disables projection. Provide a plane that covers clip space.
          skyMaterial = new SkyMaterial()
          const sky = new Mesh(new PlaneGeometry(2, 2), skyMaterial)
          sky.frustumCulled = false
          scene.add(sky)

          // SkyLightProbe computes sky irradiance of its position.
          skyLight = new SkyLightProbe()
          skyLight.position.copy(position)
          scene.add(skyLight)

          // SunDirectionalLight computes sunlight transmittance to its target position.
          sunLight = new SunDirectionalLight({ distance: 300 })
          sunLight.target.position.copy(position)
          sunLight.castShadow = true
          sunLight.shadow.camera.top = 300
          sunLight.shadow.camera.bottom = -300
          sunLight.shadow.camera.left = -300
          sunLight.shadow.camera.right = 300
          sunLight.shadow.camera.near = 0
          sunLight.shadow.camera.far = 600
          sunLight.shadow.mapSize.width = 2048
          sunLight.shadow.mapSize.height = 2048
          sunLight.shadow.normalBias = 1
          scene.add(sunLight)
          scene.add(sunLight.target)
        }

        {
          const group = new Group()
          Ellipsoid.WGS84.getEastNorthUpFrame(position).decompose(
            group.position,
            group.quaternion,
            group.scale
          )
          scene.add(group)

          const torusKnot = new Mesh(
            new TorusKnotGeometry(200, 60, 256, 64),
            new MeshPhysicalMaterial({
              color: 'white',
              roughness: 0.5,
              ior: 1.45,
              clearcoat: 1,
              clearcoatRoughness: 0.1
            })
          )
          torusKnot.castShadow = true
          torusKnot.receiveShadow = true
          group.add(torusKnot)
        }

        // Demonstrates light-source lighting here. For post-process lighting, set
        // sunLight and skyLight to true, remove SkyLightProbe and
        // SunDirectionalLight, and provide a normal buffer to
        // AerialPerspectiveEffect.
        aerialPerspective = new AerialPerspectiveEffect(camera)

        let cloud = new CloudsEffect()
				// 添加云效果

        renderer = new WebGLRenderer({
          depth: false,
          logarithmicDepthBuffer: true
        })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.toneMapping = NoToneMapping
        renderer.toneMappingExposure = 10
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = PCFSoftShadowMap

        // Use floating-point render buffer, as radiance/luminance is stored here.
        composer = new EffectComposer(renderer, {
          frameBufferType: HalfFloatType,
          multisampling: 8
        })
        composer.addPass(new RenderPass(scene, camera))
        // composer.addPass(new EffectPass(camera, aerialPerspective))
        composer.addPass(
          new EffectPass(
            camera,
            new LensFlareEffect(),
            new ToneMappingEffect({ mode: ToneMappingMode.AGX }),
            new DitheringEffect()
          )
        )

        // Generate precomputed textures.
        const generator = new PrecomputedTexturesGenerator(renderer)
        generator.update().catch(error => {
          console.error(error)
        })

        const textures = generator.textures
        Object.assign(skyMaterial, textures)
        // sunLight.transmittanceTexture = textures.transmittanceTexture
        // skyLight.irradianceTexture = textures.irradianceTexture
        Object.assign(aerialPerspective, textures)

        container.appendChild(renderer.domElement)
        window.addEventListener('resize', onWindowResize)
        renderer.setAnimationLoop(render)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function render() {
        // const date = +referenceDate + ((clock.getElapsedTime() * 5e6) % 864e5)
        // getSunDirectionECEF(date, sunDirection)
        // getMoonDirectionECEF(date, moonDirection)

        // skyMaterial.sunDirection.copy(sunDirection)
        // skyMaterial.moonDirection.copy(moonDirection)

        // sunLight.sunDirection.copy(sunDirection)
        // skyLight.sunDirection.copy(sunDirection)
        // aerialPerspective.sunDirection.copy(sunDirection)

        // sunLight.update()
        // skyLight.update()
        composer.render()
        controls.update()
      }

      init()
    </script>
  </body>
</html> -->
